# Implementation Plan: iOS-Style CLI Calculator

**Branch**: `001-ios-calc` | **Date**: 2026-01-04 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/001-ios-calc/spec.md`

## Summary

Build a beautiful, functional CLI calculator that mimics iOS design with seamless user experience. Core feature: support four basic arithmetic operations (addition, subtraction, multiplication, division) with proper decimal handling, negative number support, PEMDAS order of operations, and comprehensive error handling. Delivery includes iOS-inspired UI with responsive button feedback and clean visual hierarchy.

## Technical Context

**Language/Version**: Python 3.11+
**Primary Dependencies**: `rich` (for beautiful CLI rendering), `decimal` (for precise arithmetic), `pytest` (testing)
**Storage**: N/A (stateless, in-memory calculation)
**Testing**: pytest with unit and integration tests
**Target Platform**: Cross-platform CLI (Linux, macOS, Windows)
**Project Type**: Single Python library with CLI interface
**Performance Goals**: Response time <100ms for all operations, UI refresh <50ms
**Constraints**: Memory footprint <10MB, no external API calls, must work offline
**Scale/Scope**: Single-user CLI tool, ~500-1000 lines of code

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

✅ **Library-First Principle**: Calculator will be developed as a standalone Python library with clear separation between core calculation logic (library) and CLI interface

✅ **CLI Interface**: Core functionality exposed via CLI with text input/output protocol (stdin/args → stdout, errors → stderr), supporting both interactive mode and one-shot calculations

✅ **Test-First Approach**: Comprehensive test suite covering all arithmetic operations, error cases, decimal precision, and negative numbers (TDD mandatory)

✅ **Simplicity**: Minimal dependencies, no over-engineering, YAGNI principles applied (no persistence, no undo/redo unless required)

**Justification**: All principles are satisfied. No violations detected.

## Project Structure

### Documentation (this feature)

```text
specs/001-ios-calc/
├── plan.md              # This file (implementation strategy)
├── research.md          # Design decisions and rationale
├── data-model.md        # Calculator state and entities
├── quickstart.md        # Setup and usage guide
├── contracts/           # CLI interface specification
└── tasks.md             # Implementation tasks (generated by /sp.tasks)
```

### Source Code (repository root)

```text
calc-using-skp/
├── src/
│   ├── calculator/
│   │   ├── __init__.py
│   │   ├── engine.py         # Core calculation logic
│   │   ├── parser.py         # Expression parsing with PEMDAS
│   │   ├── validator.py      # Input validation
│   │   ├── state.py          # Calculator state management
│   │   └── errors.py         # Error definitions
│   ├── cli/
│   │   ├── __init__.py
│   │   ├── interface.py      # Interactive CLI using rich
│   │   ├── ui.py             # iOS-style UI rendering
│   │   └── main.py           # Entry point
│   └── lib.py                # Public library API
├── tests/
│   ├── unit/
│   │   ├── test_engine.py    # Calculator engine tests
│   │   ├── test_parser.py    # Parser tests
│   │   ├── test_validator.py # Input validation tests
│   │   └── test_state.py     # State management tests
│   ├── integration/
│   │   └── test_cli.py       # CLI integration tests
│   └── conftest.py           # Shared test fixtures
├── README.md
├── requirements.txt
└── setup.py
```

**Structure Decision**: Single Python library architecture with clear separation between core calculation engine (`calculator/`) and CLI interface (`cli/`). Core logic is testable independently, CLI can be tested via integration tests. This enables future port to other frontends (web, GUI, etc.).

## Design Decisions

### 1. Decimal Precision Handling
**Decision**: Use Python's `decimal.Decimal` for all arithmetic operations
**Rationale**: Solves floating-point precision issues (0.1 + 0.2 = 0.3, not 0.30000000001). Provides exact decimal arithmetic required by FR-003 and SC-002.
**Alternatives Considered**:
- Native Python floats: Would fail precision requirement SC-002
- Fractions: Overkill for calculator, slower performance

### 2. Expression Parsing with PEMDAS
**Decision**: Implement recursive descent parser for proper operator precedence
**Rationale**: Supports FR-012 requirement for standard mathematical order of operations. User clarification selected PEMDAS (not left-to-right evaluation).
**Alternatives Considered**:
- Simple left-to-right evaluation: Faster but violates FR-012
- Expression tree conversion: More complex, similar functionality

### 3. iOS-Style CLI Rendering
**Decision**: Use `rich` library for beautiful terminal rendering
**Rationale**: Provides iOS-like button grid layout, colors, animations, and visual hierarchy required by FR-005 and P2 user story. Rich is lightweight and widely available.
**Alternatives Considered**:
- ANSI codes directly: Lower-level control but verbose and error-prone
- curses: Platform-dependent, steeper learning curve
- No styling: Fails P2 user story requirement for beautiful interface

### 4. Interactive vs One-Shot Modes
**Decision**: Support both interactive mode (persistent calculator) and one-shot mode (single calculation from args)
**Rationale**: Provides flexibility for both interactive use and automation. Interactive mode better matches iOS calculator feel (P2 story).

### 5. State Management
**Decision**: Immutable calculation state with pure functions
**Rationale**: Simplifies testing, prevents bugs, makes state transitions clear and predictable. Supports continuous calculations (FR-010).

## Complexity Tracking

> No Constitution Check violations. All design decisions justified and align with project principles.

## Next Steps

1. **Phase 0**: Generate `research.md` detailing all design decisions, alternatives considered, and technical rationale
2. **Phase 1**: Create `data-model.md` and `/contracts/cli.md` documenting calculator state and CLI interface
3. **Phase 1**: Generate `quickstart.md` with setup and usage instructions
4. **Phase 2**: `/sp.tasks` command generates specific implementation tasks

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| [e.g., 4th project] | [current need] | [why 3 projects insufficient] |
| [e.g., Repository pattern] | [specific problem] | [why direct DB access insufficient] |
